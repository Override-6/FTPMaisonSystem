Index: RelayPoint/src/fr/overridescala/vps/ftp/client/RelayPoint.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.vps.ftp.client\r\n\r\nimport java.net.InetSocketAddress\r\nimport java.nio.channels.AsynchronousCloseException\r\nimport java.nio.charset.Charset\r\nimport java.nio.file.{Path, Paths}\r\n\r\nimport fr.overridescala.vps.ftp.api.`extension`.RelayExtensionLoader\r\nimport fr.overridescala.vps.ftp.api.exceptions.{PacketException, RelayClosedException, RelayException, RelayInitialisationException}\r\nimport fr.overridescala.vps.ftp.api.packet.fundamental._\r\nimport fr.overridescala.vps.ftp.api.packet.{PacketManager, _}\r\nimport fr.overridescala.vps.ftp.api.system.event.EventDispatcher\r\nimport fr.overridescala.vps.ftp.api.system.{Reason, SystemOrder, SystemPacket, SystemPacketChannel}\r\nimport fr.overridescala.vps.ftp.api.task.{Task, TaskCompleterHandler}\r\nimport fr.overridescala.vps.ftp.api.{Relay, RelayProperties}\r\nimport fr.overridescala.vps.ftp.client.RelayPoint.{Port, ServerID}\r\n\r\nimport scala.util.control.NonFatal\r\n\r\nclass RelayPoint(private val serverAddress: InetSocketAddress,\r\n                 override val identifier: String, loadTasks: Boolean) extends Relay {\r\n\r\n    override val eventDispatcher: EventDispatcher = new EventDispatcher\r\n    private val notifier = eventDispatcher.notifier\r\n\r\n    @volatile private var open = false\r\n    private val socket = new ClientDynamicSocket(serverAddress, notifier)\r\n\r\n    private val extensionFolderPath = getExtensionFolderPath\r\n    override val extensionLoader = new RelayExtensionLoader(this, extensionFolderPath)\r\n    override val properties = new RelayProperties\r\n\r\n    override val packetManager = new PacketManager(notifier)\r\n    private val packetReader = new PacketReader(socket)\r\n\r\n    private val channelsHandler = new PacketChannelsHandler(notifier, socket, packetManager)\r\n    private implicit val systemChannel: SystemPacketChannel = new SystemPacketChannel(ServerID, identifier, channelsHandler)\r\n\r\n    private val tasksHandler = new ClientTasksHandler(systemChannel, this)\r\n    override val taskCompleterHandler: TaskCompleterHandler = tasksHandler.tasksCompleterHandler\r\n\r\n\r\n    override def start(): Unit = {\r\n        println(\"Current encoding is \" + Charset.defaultCharset().name())\r\n        println(\"Listening on port \" + Port)\r\n        println(\"Computer name is \" + System.getenv().get(\"COMPUTERNAME\"))\r\n\r\n        loadLocal()\r\n        startPacketThreadListener()\r\n        loadRemote()\r\n\r\n        println(\"Ready !\")\r\n        notifier.onReady()\r\n    }\r\n\r\n    private def startPacketThreadListener(): Unit = {\r\n        val thread = new Thread(() => {\r\n            open = true\r\n            while (open && socket.isOpen)\r\n                listen()\r\n        })\r\n        thread.setName(\"RelayPoint Packet handling\")\r\n        thread.start()\r\n    }\r\n\r\n    private def loadRemote(): Unit = {\r\n        println(s\"Connecting to server with identifier '$identifier'...\")\r\n        socket.start()\r\n        val response = systemChannel.nextPacketAsP(): DataPacket\r\n        if (response.header == \"ERROR\")\r\n            throw RelayInitialisationException(s\"Another relay point with id '$identifier' is currently connected on the targeted network.\")\r\n\r\n        println(\"Connected !\")\r\n    }\r\n\r\n    private def loadLocal(): Unit = {\r\n        println(\"Loading tasks handler...\")\r\n        tasksHandler.start()\r\n        if (loadTasks) {\r\n            println(\"Loading Relay extensions from folder \" + extensionFolderPath)\r\n            extensionLoader.loadExtensions()\r\n        }\r\n        AsyncPacketChannel.UploadThread.start()\r\n        println(\"Async Upload Thread started !\")\r\n    }\r\n\r\n    override def scheduleTask[R](task: Task[R]): RelayTaskAction[R] = {\r\n        ensureOpen()\r\n        ensureTargetExists(task.targetID)\r\n\r\n        task.preInit(tasksHandler, identifier)\r\n        notifier.onTaskScheduled(task)\r\n        RelayTaskAction.of(task)\r\n    }\r\n\r\n    override def close(reason: Reason): Unit = {\r\n        close(identifier, reason)\r\n    }\r\n\r\n\r\n    override def createSyncChannel(linkedRelayID: String, id: Int): PacketChannel.Sync = {\r\n        ensureOpen()\r\n        createSyncChannel0(linkedRelayID, id)\r\n    }\r\n\r\n    override def createAsyncChannel(linkedRelayID: String, id: Int): PacketChannel.Async = {\r\n        ensureOpen()\r\n        new AsyncPacketChannel(identifier, linkedRelayID, id, channelsHandler)\r\n    }\r\n\r\n    def isConnected: Boolean = socket.isConnected\r\n\r\n    private[client] def createSyncChannel0(linkedRelayID: String, id: Int): SyncPacketChannel = {\r\n        new SyncPacketChannel(linkedRelayID, identifier, id, channelsHandler)\r\n    }\r\n\r\n    private def close(relayId: String, reason: Reason): Unit = {\r\n        if (!open)\r\n            return //already closed.\r\n        if (socket.isConnected && reason.isInternal) {\r\n            systemChannel.sendPacket(SystemPacket(SystemOrder.CLIENT_CLOSE, reason))\r\n        }\r\n\r\n        systemChannel.close(reason)\r\n        socket.close(reason)\r\n        tasksHandler.close(reason)\r\n        channelsHandler.close(reason)\r\n\r\n        open = false\r\n        notifier.onClosed(relayId, reason)\r\n        println(\"closed !\")\r\n    }\r\n\r\n\r\n    private def listen(): Unit = {\r\n        try {\r\n            val bytes = packetReader.readNextPacketBytes()\r\n            if (bytes == null)\r\n                return\r\n            val (packet, coordinates) = packetManager.toPacket(bytes)\r\n            notifier.onPacketReceived(packet)\r\n            handlePacket(packet, coordinates)\r\n        }\r\n        catch {\r\n            case _: AsynchronousCloseException =>\r\n                Console.err.println(\"Asynchronous close.\")\r\n                close(Reason.INTERNAL_ERROR)\r\n            case e: PacketException =>\r\n                Console.err.println(e.getMessage)\r\n                close(Reason.INTERNAL_ERROR)\r\n            case NonFatal(e) =>\r\n                e.printStackTrace()\r\n                Console.err.println(s\"Suddenly disconnected from the server\")\r\n                close(Reason.INTERNAL_ERROR)\r\n        }\r\n    }\r\n\r\n    private def handlePacket(packet: Packet, coordinates: PacketCoordinates): Unit = packet match {\r\n        case init: TaskInitPacket => tasksHandler.handlePacket(init, coordinates)\r\n        case system: SystemPacket => handleSystemPacket(system, coordinates)\r\n        case _: Packet => channelsHandler.injectPacket(packet, coordinates.channelID)\r\n    }\r\n\r\n\r\n    private def handleSystemPacket(system: SystemPacket, coords: PacketCoordinates): Unit = {\r\n        val order = system.order\r\n        val reason = system.reason.reversed()\r\n        val origin = coords.senderID\r\n\r\n        println(s\"Received system order $order from ${origin}\")\r\n        notifier.onSystemOrderReceived(order, reason)\r\n        order match {\r\n            case SystemOrder.CLIENT_CLOSE => close(origin, reason)\r\n            case SystemOrder.GET_IDENTIFIER => systemChannel.sendPacket(DataPacket(identifier))\r\n            case SystemOrder.ABORT_TASK => tasksHandler.skipCurrent(reason)\r\n            case _@(SystemOrder.SERVER_CLOSE | SystemOrder.CHECK_ID) => sendErrorPacket(order, \"Received forbidden order.\")\r\n            case _ => sendErrorPacket(order, \"Unknown order.\")\r\n        }\r\n\r\n        def sendErrorPacket(order: SystemOrder, cause: String): Unit = {\r\n            val error = ErrorPacket(\"SystemError\",\r\n                s\"System packet order '$order' couldn't be handled by this RelayPoint.\",\r\n                cause)\r\n            systemChannel.sendPacket(error)\r\n            error.printError()\r\n        }\r\n    }\r\n\r\n    private def getExtensionFolderPath: Path = {\r\n        val path = System.getenv().get(\"COMPUTERNAME\") match {\r\n            case \"PC_MATERIEL_NET\" => \"C:\\\\Users\\\\maxim\\\\Desktop\\\\Dev\\\\VPS\\\\ClientSide\\\\RelayExtensions\"\r\n            case _ => \"RelayExtensions/\"\r\n        }\r\n        Paths.get(path)\r\n    }\r\n\r\n    private def ensureOpen(): Unit = {\r\n        if (!open)\r\n            throw new RelayClosedException(\"Relay Point have to be started !\")\r\n    }\r\n\r\n\r\n    private def ensureTargetExists(targetID: String): Unit = {\r\n        systemChannel.sendOrder(SystemOrder.CHECK_ID, Reason.INTERNAL, targetID.getBytes)\r\n        val response = (systemChannel.nextPacketAsP(): DataPacket).header\r\n        if (response == \"ERROR\")\r\n            throw new RelayException(s\"Target '$targetID' does not exists !\")\r\n    }\r\n\r\n    //initial tasks\r\n    Runtime.getRuntime.addShutdownHook(new Thread(() => close(Reason.INTERNAL)))\r\n}\r\n\r\nobject RelayPoint {\r\n    val ServerID = \"server\"\r\n    val Port = 48484\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayPoint/src/fr/overridescala/vps/ftp/client/RelayPoint.scala	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ RelayPoint/src/fr/overridescala/vps/ftp/client/RelayPoint.scala	(date 1606255207704)
@@ -189,6 +189,7 @@
     private def getExtensionFolderPath: Path = {
         val path = System.getenv().get("COMPUTERNAME") match {
             case "PC_MATERIEL_NET" => "C:\\Users\\maxim\\Desktop\\Dev\\VPS\\ClientSide\\RelayExtensions"
+            case "LORDI-N4SO7IERS" => "D:\\Users\\Maxime\\Desktop\\Dev\\Perso\\FileTransferer\\ClientSide\\RelayExtensions"
             case _ => "RelayExtensions/"
         }
         Paths.get(path)
Index: API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlock.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlock.scala	(date 1606255214405)
+++ API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlock.scala	(date 1606255214405)
@@ -0,0 +1,7 @@
+package fr.overridescala.vps.ftp.api.task.concurency
+
+trait TaskBlock {
+
+      def start(): Unit
+
+}
Index: CloudStorage/src/fr/overridescala/vps/ftp/extension/cloud/tasks/DownloadTask.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.vps.ftp.`extension`.cloud.tasks\r\n\r\nimport java.io.File\r\nimport java.nio.file.{Files, Path}\r\n\r\nimport fr.overridescala.vps.ftp.`extension`.cloud.tasks.DownloadTask.TYPE\r\nimport fr.overridescala.vps.ftp.`extension`.cloud.transfer.TransferDescription\r\nimport fr.overridescala.vps.ftp.api.exceptions.TaskException\r\nimport fr.overridescala.vps.ftp.api.packet.Packet\r\nimport fr.overridescala.vps.ftp.api.packet.fundamental.{DataPacket, ErrorPacket}\r\nimport fr.overridescala.vps.ftp.api.task.{Task, TaskInitInfo}\r\nimport fr.overridescala.vps.ftp.api.utils.Utils\r\n\r\n/**\r\n * Downloads a File or folder from a targeted Relay\r\n *\r\n * @param desc the description about this transfer\r\n * @see [[TransferDescription]]\r\n * */\r\nclass DownloadTask private(private val desc: TransferDescription)\r\n        extends Task[Unit](desc.targetID) {\r\n\r\n    private var totalBytesWritten = 0\r\n\r\n    override val initInfo: TaskInitInfo =\r\n        TaskInitInfo.of(TYPE, desc.targetID, Utils.serialize(desc))\r\n\r\n    override def execute(): Unit = {\r\n        val response = nextPacket(): DataPacket\r\n        //empty upload check\r\n        if (response.header == UploadTask.END_OF_TRANSFER) {\r\n            success()\r\n            return\r\n        }\r\n        val downloadPath = findDownloadPath(response)\r\n        try {\r\n            downloadFile(downloadPath)\r\n        } catch {\r\n            case e: Throwable =>\r\n                e.printStackTrace()\r\n                val typeName = e.getClass.getCanonicalName\r\n                val errMsg = e.getMessage\r\n                var msg = s\"$typeName : $errMsg\"\r\n                if (errMsg == null)\r\n                    msg = s\"got an error of type : $typeName\"\r\n                channel.sendPacket(ErrorPacket(typeName, msg))\r\n                fail(msg)\r\n        }\r\n    }\r\n\r\n\r\n    private def downloadFile(downloadPath: Path): Unit = {\r\n        println(s\"DOWNLOAD START $downloadPath\")\r\n        if (checkPath(downloadPath))\r\n            return\r\n        val stream = Files.newOutputStream(downloadPath)\r\n        var count = 0\r\n        var packet = nextPacket(): DataPacket\r\n\r\n        def downloading: Boolean = packet.header != UploadTask.UPLOAD_FILE && packet.header != UploadTask.END_OF_TRANSFER\r\n\r\n        while (downloading) {\r\n            totalBytesWritten += packet.content.length\r\n            stream.write(packet.content)\r\n            count += 1\r\n            packet = nextPacket(): DataPacket\r\n            println(s\"received = $totalBytesWritten, packets exchange = $count\")\r\n        }\r\n        println()\r\n        stream.close()\r\n        handleLastTransferResponse(packet)\r\n    }\r\n\r\n    private def findDownloadPath(packet: DataPacket): Path = {\r\n        Utils.checkPacketHeader(packet, Array(\"UPF\"))\r\n        val source = Utils.formatPath(desc.source).toString\r\n        val root = Utils.formatPath(source.substring(0, source.lastIndexOf(File.separatorChar)))\r\n        val rootNameCount = root.toString.count(_ == File.separatorChar)\r\n\r\n        val uploadedFile = Utils.formatPath(new String(packet.content))\r\n        val destination = Utils.formatPath(new String(desc.destination))\r\n\r\n        val relativePath = Utils.subPathOfUnknownFile(uploadedFile, rootNameCount)\r\n        Utils.formatPath(destination.toString + relativePath)\r\n    }\r\n\r\n\r\n    private def handleLastTransferResponse(packet: DataPacket): Unit = {\r\n        val header = packet.header\r\n        Utils.checkPacketHeader(packet, Array(UploadTask.END_OF_TRANSFER, UploadTask.UPLOAD_FILE))\r\n        if (header.equals(UploadTask.END_OF_TRANSFER))\r\n            success()\r\n        else if (header.equals(UploadTask.UPLOAD_FILE)) {\r\n            val downloadPath = findDownloadPath(packet)\r\n            downloadFile(downloadPath)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check the validity of this transfer\r\n     *\r\n     * @return true if the transfer needs to be aborted, false instead\r\n     * */\r\n    private def checkPath(path: Path): Boolean = {\r\n        if (Files.notExists(path)) {\r\n            Files.createDirectories(path)\r\n            Files.delete(path)\r\n            Files.createFile(path)\r\n        }\r\n        if (!Files.isWritable(path) || !Files.isReadable(path)) {\r\n            val errorMsg = s\"($path) Can't access to the file\"\r\n            channel.sendPacket(ErrorPacket(\"NoSuchPermissions\", errorMsg))\r\n            fail(errorMsg)\r\n            return true\r\n        }\r\n        false\r\n    }\r\n\r\n    private def nextPacket[P <: Packet](): P = {\r\n        val packet = channel.nextPacket()\r\n        packet match {\r\n            case error: ErrorPacket =>\r\n                throw new TaskException(error.errorMsg)\r\n            case desired: P => desired\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nobject DownloadTask {\r\n    val TYPE: String = \"DWN\"\r\n\r\n    def apply(transferDescription: TransferDescription): DownloadTask =\r\n        new DownloadTask(transferDescription)\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- CloudStorage/src/fr/overridescala/vps/ftp/extension/cloud/tasks/DownloadTask.scala	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ CloudStorage/src/fr/overridescala/vps/ftp/extension/cloud/tasks/DownloadTask.scala	(date 1606255213483)
@@ -64,7 +64,6 @@
             stream.write(packet.content)
             count += 1
             packet = nextPacket(): DataPacket
-            println(s"received = $totalBytesWritten, packets exchange = $count")
         }
         println()
         stream.close()
Index: RelayServer/RelayServer.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"module\" module-name=\"API\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"library\" name=\"annotations-16.0.1\" level=\"project\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayServer/RelayServer.iml	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ RelayServer/RelayServer.iml	(date 1606255214472)
@@ -9,6 +9,6 @@
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="API" />
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
-    <orderEntry type="library" name="annotations-16.0.1" level="project" />
+    <orderEntry type="library" name="org.jetbrains:annotations:16.0.2" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlockItem.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlockItem.scala	(date 1606255214296)
+++ API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlockItem.scala	(date 1606255214296)
@@ -0,0 +1,7 @@
+package fr.overridescala.vps.ftp.api.task.concurency
+
+import fr.overridescala.vps.ftp.api.task.Task
+
+class TaskBlockItem[T, A](task: Task[T], child: TaskBlockItem[A, _]) {
+
+}
Index: API/API.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"library\" name=\"annotations-16.0.1\" level=\"project\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/API.iml	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ API/API.iml	(date 1606255214503)
@@ -8,6 +8,6 @@
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
-    <orderEntry type="library" name="annotations-16.0.1" level="project" />
+    <orderEntry type="library" name="org.jetbrains:annotations:16.0.2" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: FileTransferer.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- FileTransferer.iml	(date 1606255214343)
+++ FileTransferer.iml	(date 1606255214343)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/API/src" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
+  </component>
+</module>
\ No newline at end of file
Index: RelayController/RelayController.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"module\" module-name=\"API\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"library\" name=\"annotations-16.0.1\" level=\"project\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayController/RelayController.iml	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ RelayController/RelayController.iml	(date 1606255215300)
@@ -4,11 +4,12 @@
     <exclude-output />
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/resource" type="java-resource" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="API" />
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
-    <orderEntry type="library" name="annotations-16.0.1" level="project" />
+    <orderEntry type="library" name="org.jetbrains:annotations:16.0.2" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: CloudStorage/CloudStorage.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"module\" module-name=\"API\" />\r\n    <orderEntry type=\"module\" module-name=\"RelayController\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"library\" name=\"annotations-16.0.1\" level=\"project\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- CloudStorage/CloudStorage.iml	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ CloudStorage/CloudStorage.iml	(date 1606255215269)
@@ -4,12 +4,13 @@
     <exclude-output />
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/resource" type="java-resource" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="API" />
     <orderEntry type="module" module-name="RelayController" />
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
-    <orderEntry type="library" name="annotations-16.0.1" level="project" />
+    <orderEntry type="library" name="org.jetbrains:annotations:16.0.2" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: API/src/fr/overridescala/vps/ftp/api/extension/packet/TestPacket.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/vps/ftp/api/extension/packet/TestPacket.scala	(date 1606255214264)
+++ API/src/fr/overridescala/vps/ftp/api/extension/packet/TestPacket.scala	(date 1606255214264)
@@ -0,0 +1,39 @@
+package fr.overridescala.vps.ftp.api.`extension`.packet
+
+import fr.overridescala.vps.ftp.api.`extension`.packet.PacketMacros.packet
+import fr.overridescala.vps.ftp.api.packet.Packet
+
+//TODO Doc
+/**
+ * this class is used to represent a packet to send or to receive.
+ * It allows the user and the program to work easier with the packets.
+ * a DataPacket can only be send into tasks
+ *
+ * @param header  the header of the packet, or the type of this data. Headers allows to classify packets / data to send or receive
+ * @param content the content of this packet. can be an [[Object]], a [[String]] or whatever. default content is empty
+ * */
+@packet
+class TestPacket(override val channelID: Int,
+                 override val targetID: String,
+                 override val senderID: String,
+                 val header: String,
+                 val content: Array[Byte] = Array()) extends Packet {
+
+    val contentAsString: String = new String(content)
+
+    /**
+     * Represents this packet as a String
+     * */
+    override def toString: String =
+        s"DataPacket{id: $channelID, header: $header, target: $targetID, sender: $senderID, content: ${new String(content)}}"
+
+    /**
+     * @return true if this packet contains content, false instead
+     * */
+    lazy val haveContent: Boolean = !content.isEmpty
+
+}
+
+
+
+
Index: API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlockBuilder.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlockBuilder.scala	(date 1606255214436)
+++ API/src/fr/overridescala/vps/ftp/api/task/concurency/TaskBlockBuilder.scala	(date 1606255214436)
@@ -0,0 +1,21 @@
+package fr.overridescala.vps.ftp.api.task.concurency
+
+import fr.overridescala.vps.ftp.api.task.Task
+
+class TaskBlockBuilder {
+
+      private var firstItem = TaskBlockItemBuilder
+
+      def make[T](task: Task[T]): TaskBlockItemBuilder[T] = TaskBlockItemBuilder(task)
+
+      /*def runAsync(): TaskBlock = {
+
+      }*/
+
+      case class TaskBlockItemBuilder[T](task: Task[T]) {
+            def thenMake[A](supplier: T => Task[A]): TaskBlockItemBuilder[A] = {
+                  TaskBlockItemBuilder(supplier(task.complete()))
+            }
+      }
+
+}
Index: RelayServer/src/fr/overridescala/vps/ftp/server/connection/ConnectionsManager.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.vps.ftp.server.connection\r\n\r\nimport java.net.InetSocketAddress\r\n\r\nimport fr.overridescala.vps.ftp.api.exceptions.{RelayException, RelayInitialisationException}\r\nimport fr.overridescala.vps.ftp.api.system.{JustifiedCloseable, Reason}\r\nimport fr.overridescala.vps.ftp.server.RelayServer\r\n\r\nimport scala.collection.mutable\r\n\r\n/**\r\n * TeamMate of RelayServer, handles the RelayPoint Connections.\r\n *\r\n * @see [[RelayServer]]\r\n * @see [[ClientConnectionThread]]\r\n * */\r\nclass ConnectionsManager(server: RelayServer) extends JustifiedCloseable {\r\n    /**\r\n     * java map containing all RelayPointConnection instances\r\n     * */\r\n    private val connections: mutable.Map[String, ClientConnectionThread] = mutable.Map.empty\r\n\r\n    override def close(reason: Reason): Unit = {\r\n        for ((_, connection) <- connections)\r\n            connection.close(reason)\r\n    }\r\n\r\n    /**\r\n     * creates and register a RelayPoint connection.\r\n     *\r\n     * @param socket the socket to start the connection\r\n     * @throws RelayInitialisationException when a id is already set for this address, or another connection is known under this id.\r\n     * */\r\n    def register(socket: SocketContainer, identifier: String): Unit = {\r\n        if (connections.contains(identifier))\r\n            throw RelayInitialisationException(s\"This relay id is already registered ! ('$identifier')\")\r\n\r\n        val connection = ClientConnectionThread.open(socket, server, identifier)\r\n        println(s\"Relay Point connected with identifier '${connection.identifier}'\")\r\n        connections.put(identifier, connection)\r\n    }\r\n\r\n    /**\r\n     * unregisters a Relay point\r\n     *\r\n     * @param identifier the identifier to disconnect\r\n     * */\r\n    def unregister(identifier: String): Unit =\r\n        connections.remove(identifier)\r\n\r\n\r\n    /**\r\n     * retrieves a RelayPointConnection based on the address\r\n     *\r\n     * @param identifier the identifier linked [[ClientConnectionThread]]\r\n     * @return the found [[ClientConnectionThread]] bound with the identifier\r\n     * */\r\n    def getConnectionFromIdentifier(identifier: String): ClientConnectionThread = {\r\n        for ((_, connection) <- connections) {\r\n            val connectionIdentifier = connection.tasksHandler.identifier\r\n            if (connectionIdentifier.equals(identifier))\r\n                return connection\r\n        }\r\n        null\r\n    }\r\n\r\n    /**\r\n     * determines if the address is not registered\r\n     *\r\n     * @param identifier the identifier to test\r\n     * @return true if the address is not registered, false instead\r\n     * */\r\n    def isNotRegistered(identifier: String): Boolean = {\r\n        !connections.contains(identifier)\r\n    }\r\n\r\n    /**\r\n     * @param identifier the identifier to test\r\n     * @return true if any connected Relay have the specified identifier\r\n     * */\r\n    def containsIdentifier(identifier: String): Boolean = {\r\n        for (connection <- connections.values) {\r\n            val connectionIdentifier = connection.tasksHandler.identifier\r\n            if (connectionIdentifier.equals(identifier))\r\n                return true\r\n        }\r\n        identifier == server.identifier //blacklists server identifier\r\n    }\r\n\r\n\r\n    /**\r\n     * Deflects a packet to his associated [[ClientConnectionThread]]\r\n     *\r\n     * @throws RelayException if no connection where found for this packet.\r\n     * @param bytes the packet bytes to deflect\r\n     * */\r\n    private[connection] def deflectTo(bytes: Array[Byte], target: String): Unit = {\r\n        val connection = getConnectionFromIdentifier(target)\r\n        if (connection == null)\r\n            throw new RelayException(s\"unknown ID '$target' to deflect packet\")\r\n        connection.sendDeflectedBytes(bytes)\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayServer/src/fr/overridescala/vps/ftp/server/connection/ConnectionsManager.scala	(revision 0b451dce4da2c7d2cb8952fc1ab707bc74b3a767)
+++ RelayServer/src/fr/overridescala/vps/ftp/server/connection/ConnectionsManager.scala	(date 1606255214374)
@@ -36,7 +36,6 @@
             throw RelayInitialisationException(s"This relay id is already registered ! ('$identifier')")
 
         val connection = ClientConnectionThread.open(socket, server, identifier)
-        println(s"Relay Point connected with identifier '${connection.identifier}'")
         connections.put(identifier, connection)
     }
 
diff --git RelayController/src/extension.properties RelayController/resource/extension.properties
rename from RelayController/src/extension.properties
rename to RelayController/resource/extension.properties
diff --git CloudStorage/src/extension.properties CloudStorage/resource/extension.properties
rename from CloudStorage/src/extension.properties
rename to CloudStorage/resource/extension.properties
