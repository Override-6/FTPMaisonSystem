Index: RelayServer/src/fr/overridescala/linkkit/server/RelayServer.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.linkkit.server\r\n\r\nimport java.net.{ServerSocket, SocketException}\r\nimport java.nio.charset.Charset\r\nimport java.nio.file.{Path, Paths}\r\n\r\nimport fr.overridescala.linkkit.api.Relay\r\nimport fr.overridescala.linkkit.api.`extension`.{RelayExtensionLoader, RelayProperties}\r\nimport fr.overridescala.linkkit.api.exceptions.{RelayClosedException, RelayException}\r\nimport fr.overridescala.linkkit.api.packet._\r\nimport fr.overridescala.linkkit.api.packet.channel.PacketChannel\r\nimport fr.overridescala.linkkit.api.packet.collector.{AsyncPacketCollector, PacketCollector, SyncPacketCollector}\r\nimport fr.overridescala.linkkit.api.packet.fundamental.DataPacket\r\nimport fr.overridescala.linkkit.api.system.event.EventObserver\r\nimport fr.overridescala.linkkit.api.system._\r\nimport fr.overridescala.linkkit.api.task.{Task, TaskCompleterHandler}\r\nimport fr.overridescala.linkkit.server.RelayServer.Identifier\r\nimport fr.overridescala.linkkit.server.connection.{ClientConnection, ConnectionsManager, SocketContainer}\r\n\r\nimport scala.util.control.NonFatal\r\n\r\nobject RelayServer {\r\n    val version: Version = Version(\"RelayServer\", \"0.5.0\", stable = false)\r\n\r\n    val Identifier = \"server\"\r\n}\r\n\r\nclass RelayServer extends Relay {\r\n\r\n    private val serverSocket = new ServerSocket(48484)\r\n    private val taskFolderPath = getTasksFolderPath\r\n\r\n    @volatile private var open = false\r\n    /**\r\n     * For safety, prefer Relay#identfier instead of Constants.SERVER_ID\r\n     * */\r\n    override val identifier: String = Identifier\r\n    override val eventObserver: EventObserver = new EventObserver\r\n    override val extensionLoader = new RelayExtensionLoader(this, taskFolderPath)\r\n    override val taskCompleterHandler = new TaskCompleterHandler\r\n    override val properties: RelayProperties = new RelayProperties\r\n    override val packetManager = new PacketManager(eventObserver.notifier)\r\n\r\n    override val relayVersion: Version = RelayServer.version\r\n\r\n    private[server] val notifier = eventObserver.notifier\r\n\r\n    val trafficHandler = new ServerTrafficHandler(this)\r\n    val connectionsManager = new ConnectionsManager(this)\r\n    private val remoteConsoles: RemoteConsolesHandler = new RemoteConsolesHandler(this)\r\n\r\n    override def scheduleTask[R](task: Task[R]): RelayTaskAction[R] = {\r\n        ensureOpen()\r\n        val targetIdentifier = task.targetID\r\n        val connection = getConnection(targetIdentifier)\r\n        if (connection == null)\r\n            throw new NoSuchElementException(s\"Unknown or unregistered relay with identifier '$targetIdentifier'\")\r\n\r\n        val tasksHandler = connection.getTasksHandler\r\n        task.preInit(tasksHandler)\r\n        notifier.onTaskScheduled(task)\r\n        RelayTaskAction.of(task)\r\n    }\r\n\r\n    override def start(): Unit = {\r\n        println(\"Current encoding is \" + Charset.defaultCharset().name())\r\n        println(\"Listening on port \" + serverSocket.getLocalPort)\r\n        println(\"Computer name is \" + System.getenv().get(\"COMPUTERNAME\"))\r\n        println(relayVersion)\r\n        println(apiVersion)\r\n\r\n        extensionLoader.loadExtensions()\r\n\r\n        println(\"Ready !\")\r\n        notifier.onReady()\r\n\r\n        open = true\r\n        while (open) handleSocketConnection()\r\n    }\r\n\r\n\r\n    override def createSyncChannel(linkedRelayID: String, id: Int): PacketChannel.Sync = {\r\n        val targetConnection = getConnection(linkedRelayID)\r\n        targetConnection.createSync(id)\r\n    }\r\n\r\n\r\n    override def createAsyncChannel(linkedRelayID: String, id: Int): PacketChannel.Async = {\r\n        val targetConnection = getConnection(linkedRelayID)\r\n        targetConnection.createAsync(id)\r\n    }\r\n\r\n    override def createSyncCollector(id: Int): PacketCollector.Sync = {\r\n        new SyncPacketCollector(trafficHandler, id)\r\n    }\r\n\r\n    override def createAsyncCollector(id: Int): PacketCollector.Async = {\r\n        new AsyncPacketCollector(trafficHandler, id)\r\n    }\r\n\r\n    override def getConsoleOut(targetId: String): Option[RemoteConsole] = {\r\n        val connection = getConnection(targetId)\r\n        if (connection == null)\r\n            return Option.empty\r\n\r\n        Option(remoteConsoles.getOut(targetId))\r\n    }\r\n\r\n    override def getConsoleErr(targetId: String): Option[RemoteConsole.Err] = {\r\n        val connection = getConnection(targetId)\r\n        if (connection == null)\r\n            return Option.empty\r\n\r\n        Option(remoteConsoles.getErr(targetId))\r\n    }\r\n\r\n    override def close(reason: Reason): Unit =\r\n        close(identifier, reason)\r\n\r\n\r\n    def close(relayId: String, reason: Reason): Unit = {\r\n        println(\"closing server...\")\r\n        connectionsManager.close(reason)\r\n        serverSocket.close()\r\n\r\n        open = false\r\n        notifier.onClosed(relayId, reason)\r\n        println(\"server closed !\")\r\n    }\r\n\r\n    def getConnection(relayIdentifier: String): ClientConnection = {\r\n        ensureOpen()\r\n        connectionsManager.getConnectionFromIdentifier(relayIdentifier)\r\n    }\r\n\r\n    private val tempSocket = new SocketContainer(notifier, false)\r\n\r\n    private def handleRelayPointConnection(identifier: String): Unit = {\r\n\r\n        if (connectionsManager.isNotRegistered(identifier)) {\r\n            val socketContainer = new SocketContainer(notifier, true)\r\n            socketContainer.set(tempSocket.get)\r\n            connectionsManager.register(socketContainer, identifier)\r\n            sendResponse(\"OK\")\r\n            return\r\n        }\r\n\r\n        val connection = getConnection(identifier)\r\n        if (connection.isConnected) {\r\n            Console.err.println(\"Rejected connection of a client because he gave an already registered relay identifier.\")\r\n            sendResponse(\"ERROR\")\r\n            return\r\n        }\r\n\r\n        connection.updateSocket(tempSocket.get)\r\n        sendResponse(\"OK\")\r\n    }\r\n\r\n    private def handleSocketConnection(): Unit = {\r\n        try {\r\n            val clientSocket = serverSocket.accept()\r\n            tempSocket.set(clientSocket)\r\n\r\n            val identifier = ClientConnection.retrieveIdentifier(tempSocket, this)\r\n            handleRelayPointConnection(identifier)\r\n        } catch {\r\n            case e@(_: RelayException | _: SocketException) =>\r\n                Console.err.println(e.getMessage)\r\n                onException()\r\n\r\n            case NonFatal(e) =>\r\n                e.printStackTrace()\r\n                onException()\r\n        }\r\n\r\n        def onException(): Unit = {\r\n            sendResponse(\"ERROR\") //send a negative response for the client initialisation handling\r\n            close(Reason.INTERNAL_ERROR)\r\n        }\r\n    }\r\n\r\n    private def getTasksFolderPath: Path = {\r\n        val path = System.getenv().get(\"COMPUTERNAME\") match {\r\n            case \"PC_MATERIEL_NET\" => \"C:\\\\Users\\\\maxim\\\\Desktop\\\\Dev\\\\VPS\\\\ClientSide\\\\RelayExtensions\"\r\n            case _ => \"RelayExtensions/\"\r\n        }\r\n        Paths.get(path)\r\n    }\r\n\r\n    private def ensureOpen(): Unit = {\r\n        if (!open)\r\n            throw new RelayClosedException(\"Relay Server have to be started !\")\r\n    }\r\n\r\n    private def sendResponse(response: String): Unit = {\r\n        val responsePacket = DataPacket(response)\r\n        val coordinates = PacketCoordinates(SystemPacketChannel.SystemChannelID, \"unknown\", identifier)\r\n        tempSocket.write(packetManager.toBytes(responsePacket, coordinates))\r\n    }\r\n\r\n    Runtime.getRuntime.addShutdownHook(new Thread(() => close(Reason.INTERNAL)))\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayServer/src/fr/overridescala/linkkit/server/RelayServer.scala	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ RelayServer/src/fr/overridescala/linkkit/server/RelayServer.scala	(date 1607515023459)
@@ -120,6 +120,8 @@
 
     def close(relayId: String, reason: Reason): Unit = {
         println("closing server...")
+
+        extensionLoader.close()
         connectionsManager.close(reason)
         serverSocket.close()
 
Index: API/src/fr/overridescala/linkkit/api/extension/ExtensionLoaderNode.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.linkkit.api.`extension`\r\n\r\nimport fr.overridescala.linkkit.api.Relay\r\nimport fr.overridescala.linkkit.api.exceptions.RelayException\r\n\r\nimport scala.collection.mutable\r\nimport scala.collection.mutable.ListBuffer\r\n\r\ncase class ExtensionLoaderNode(extensionInfo: ExtensionInfo, implementorExtensions: Array[ExtensionLoaderNode]) {\r\n\r\n    private var isLoaded = false\r\n\r\n    val weight: Int = {\r\n        var count = implementorExtensions.length\r\n        for (ext <- implementorExtensions)\r\n            count = ext.weight\r\n        count\r\n    }\r\n\r\n    def load(relay: Relay): Unit = {\r\n        if (isLoaded)\r\n            return\r\n        try {\r\n            val constructor = extensionInfo.extensionClass.getConstructor(classOf[Relay])\r\n            constructor.setAccessible(true)\r\n            val extension = constructor.newInstance(relay)\r\n            println(s\"Relay extension ${extensionInfo.name} loaded successfully !\")\r\n            extension.main()\r\n            relay.eventObserver.notifier.onExtensionLoaded(extension)\r\n        } catch {\r\n            case _: NoSuchMethodException =>\r\n                throw new RelayException(s\"Could not load '${extensionInfo.name} : Constructor(Relay) is missing !\")\r\n        } finally {\r\n            isLoaded = true\r\n        }\r\n        implementorExtensions.foreach(_.load(relay))\r\n    }\r\n\r\n}\r\n\r\nobject ExtensionLoaderNode {\r\n\r\n    def loadGraph(relay: Relay, extensionsInfo: Seq[ExtensionInfo]): Unit = {\r\n        makeGraph(extensionsInfo).foreach(_.load(relay))\r\n    }\r\n\r\n    private def makeGraph(extensionsInfo: Seq[ExtensionInfo]): Array[ExtensionLoaderNode] = {\r\n        val dependencyMaps = mutable.Map.empty[String, ListBuffer[ExtensionInfo]]\r\n        for (ext <- extensionsInfo) {\r\n            val dependencies = ext.dependencies\r\n\r\n            for (dep <- dependencies) {\r\n                if (!dependencyMaps.contains(dep)) {\r\n                    dependencyMaps.put(dep, ListBuffer.empty)\r\n                }\r\n                dependencyMaps(dep) += ext\r\n            }\r\n        }\r\n\r\n        val nodeCache = mutable.Map.empty[String, ExtensionLoaderNode]\r\n        val nameCache = ListBuffer.empty[String]\r\n\r\n        def createNode(ext: ExtensionInfo): ExtensionLoaderNode = {\r\n            val name = ext.name\r\n            nameCache += name\r\n            val implementorsOpt = dependencyMaps.get(name)\r\n            if (implementorsOpt.isEmpty) {\r\n                if (nodeCache.contains(name))\r\n                    return nodeCache(name)\r\n                val node = new ExtensionLoaderNode(ext, Array())\r\n                nodeCache.put(name, node)\r\n                return node\r\n            }\r\n\r\n            val implementors = implementorsOpt.get\r\n            val implementorsList = ListBuffer.empty[ExtensionLoaderNode]\r\n\r\n            for (impl <- implementors) {\r\n                if (!nameCache.contains(impl.name))\r\n                    implementorsList += createNode(impl)\r\n            }\r\n\r\n            val node = new ExtensionLoaderNode(ext, implementorsList.toArray)\r\n            nodeCache.put(ext.name, node)\r\n            node\r\n        }\r\n\r\n        val roots = ListBuffer.empty[ExtensionLoaderNode]\r\n        for (ext <- extensionsInfo) {\r\n            if (ext.haveNoDependencies)\r\n                roots += createNode(ext)\r\n        }\r\n        roots.toArray\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/linkkit/api/extension/ExtensionLoaderNode.scala	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ API/src/fr/overridescala/linkkit/api/extension/ExtensionLoaderNode.scala	(date 1607514557845)
@@ -20,19 +20,9 @@
     def load(relay: Relay): Unit = {
         if (isLoaded)
             return
-        try {
-            val constructor = extensionInfo.extensionClass.getConstructor(classOf[Relay])
-            constructor.setAccessible(true)
-            val extension = constructor.newInstance(relay)
-            println(s"Relay extension ${extensionInfo.name} loaded successfully !")
-            extension.main()
-            relay.eventObserver.notifier.onExtensionLoaded(extension)
-        } catch {
-            case _: NoSuchMethodException =>
-                throw new RelayException(s"Could not load '${extensionInfo.name} : Constructor(Relay) is missing !")
-        } finally {
-            isLoaded = true
-        }
+        relay.extensionLoader.loadExtension(extensionInfo.extensionClass)
+        isLoaded = true
+
         implementorExtensions.foreach(_.load(relay))
     }
 
Index: RelayPoint/src/fr/overridescala/linkkit/client/RelayPoint.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.linkkit.client\r\n\r\nimport java.net.InetSocketAddress\r\nimport java.nio.channels.AsynchronousCloseException\r\nimport java.nio.charset.Charset\r\nimport java.nio.file.{Path, Paths}\r\n\r\nimport fr.overridescala.linkkit.api.Relay\r\nimport fr.overridescala.linkkit.api.`extension`.{RelayExtensionLoader, RelayProperties}\r\nimport fr.overridescala.linkkit.api.exceptions.{RelayClosedException, RelayException, RelayInitialisationException}\r\nimport fr.overridescala.linkkit.api.packet.channel.{AsyncPacketChannel, PacketChannel, SyncPacketChannel}\r\nimport fr.overridescala.linkkit.api.packet.collector.{AsyncPacketCollector, PacketCollector, SyncPacketCollector}\r\nimport fr.overridescala.linkkit.api.packet.fundamental._\r\nimport fr.overridescala.linkkit.api.packet.{PacketManager, _}\r\nimport fr.overridescala.linkkit.api.system._\r\nimport fr.overridescala.linkkit.api.system.event.EventObserver\r\nimport fr.overridescala.linkkit.api.task.{Task, TaskCompleterHandler}\r\nimport fr.overridescala.linkkit.client.RelayPoint.{Port, ServerID}\r\n\r\nimport scala.util.control.NonFatal\r\n\r\nobject RelayPoint {\r\n    val version: Version = Version(\"RelayPoint\", \"0.4.0\", stable = false)\r\n\r\n    val ServerID = \"server\"\r\n    val Port = 48484\r\n}\r\n\r\nclass RelayPoint(private val serverAddress: InetSocketAddress,\r\n                 override val identifier: String, loadTasks: Boolean) extends Relay {\r\n\r\n    override val eventObserver: EventObserver = new EventObserver\r\n    private val notifier = eventObserver.notifier\r\n\r\n    @volatile private var open = false\r\n    private val socket = new ClientDynamicSocket(serverAddress, notifier)\r\n\r\n    @volatile private var serverErrConsole: RemoteConsole.Err = _ //affected once Relay initialised\r\n\r\n    override val packetManager = new PacketManager(notifier)\r\n\r\n    private val extensionFolderPath = getExtensionFolderPath\r\n    override val extensionLoader = new RelayExtensionLoader(this, extensionFolderPath)\r\n    override val properties = new RelayProperties\r\n\r\n    private val traffic = new SimpleTrafficHandler(notifier, socket, identifier, packetManager)\r\n    private implicit val systemChannel: SystemPacketChannel = new SystemPacketChannel(ServerID, traffic)\r\n\r\n    private val tasksHandler = new ClientTasksHandler(systemChannel, this)\r\n    override val taskCompleterHandler: TaskCompleterHandler = tasksHandler.tasksCompleterHandler\r\n    private val remoteConsoles = new RemoteConsolesHandler(this)\r\n\r\n    override val relayVersion: Version = RelayPoint.version\r\n\r\n    override def start(): Unit = {\r\n        println(\"Current encoding is \" + Charset.defaultCharset().name())\r\n        println(\"Listening on port \" + Port)\r\n        println(\"Computer name is \" + System.getenv().get(\"COMPUTERNAME\"))\r\n        println(relayVersion)\r\n        println(apiVersion)\r\n\r\n        loadLocal()\r\n        startPacketThreadListener()\r\n        loadRemote()\r\n\r\n        println(\"Ready !\")\r\n        notifier.onReady()\r\n    }\r\n\r\n    private def startPacketThreadListener(): Unit = {\r\n        val thread = new Thread(() => {\r\n            val packetReader = new PacketReader(socket, serverErrConsole)\r\n            open = true\r\n            while (open && socket.isOpen)\r\n                listen(packetReader)\r\n            open = false\r\n        })\r\n        thread.setName(\"RelayPoint Packet Handling\")\r\n        thread.start()\r\n    }\r\n\r\n    private def loadRemote(): Unit = {\r\n        println(s\"Connecting to server with identifier '$identifier'...\")\r\n        socket.start()\r\n\r\n        val response = systemChannel.nextPacketAsP(): DataPacket\r\n        if (response.header == \"ERROR\")\r\n            throw RelayInitialisationException(s\"Another relay point with id '$identifier' is currently connected on the targeted network.\")\r\n\r\n        val outOpt = getConsoleOut(ServerID)\r\n        val errOpt = getConsoleErr(ServerID)\r\n        if (outOpt.isEmpty || errOpt.isEmpty)\r\n            throw RelayInitialisationException(\"Could not retrieve remote console of server\")\r\n        serverErrConsole = errOpt.get\r\n\r\n        systemChannel.sendOrder(SystemOrder.PRINT_VERSION, Reason.INTERNAL)\r\n        println(\"Connected !\")\r\n\r\n    }\r\n\r\n    private def loadLocal(): Unit = {\r\n        println(\"Loading tasks handler...\")\r\n        tasksHandler.start()\r\n        if (loadTasks) {\r\n            println(\"Loading Relay extensions from folder \" + extensionFolderPath)\r\n            extensionLoader.loadExtensions()\r\n        }\r\n        println(\"Async Upload Thread started !\")\r\n    }\r\n\r\n    override def scheduleTask[R](task: Task[R]): RelayTaskAction[R] = {\r\n        ensureOpen()\r\n        ensureTargetValid(task.targetID)\r\n\r\n        task.preInit(tasksHandler)\r\n        notifier.onTaskScheduled(task)\r\n        RelayTaskAction.of(task)\r\n    }\r\n\r\n    override def close(reason: Reason): Unit = {\r\n        close(identifier, reason)\r\n    }\r\n\r\n    override def createSyncChannel(linkedRelayID: String, id: Int): PacketChannel.Sync = {\r\n        new SyncPacketChannel(linkedRelayID, id, traffic)\r\n    }\r\n\r\n    override def createAsyncChannel(linkedRelayID: String, id: Int): PacketChannel.Async = {\r\n        new AsyncPacketChannel(linkedRelayID, id, traffic)\r\n    }\r\n\r\n    override def createAsyncCollector(id: Int): PacketCollector.Async = {\r\n        new AsyncPacketCollector(traffic, id)\r\n    }\r\n\r\n    override def createSyncCollector(id: Int): PacketCollector.Sync = {\r\n        new SyncPacketCollector(traffic, id)\r\n    }\r\n\r\n    override def getConsoleOut(targetId: String): Option[RemoteConsole] = Option(remoteConsoles.getOut(targetId))\r\n\r\n    override def getConsoleErr(targetId: String): Option[RemoteConsole.Err] = Option(remoteConsoles.getErr(targetId))\r\n\r\n    def isConnected: Boolean = socket.isConnected\r\n\r\n    private def close(relayId: String, reason: Reason): Unit = {\r\n        if (!open)\r\n            return //already closed.\r\n\r\n        if (socket.isConnected && reason.isInternal) {\r\n            systemChannel.sendPacket(SystemPacket(SystemOrder.CLIENT_CLOSE, reason))\r\n        }\r\n\r\n        systemChannel.close(reason)\r\n        socket.close(reason)\r\n        tasksHandler.close(reason)\r\n        traffic.close(reason)\r\n\r\n        open = false\r\n        notifier.onClosed(relayId, reason)\r\n        println(\"closed !\")\r\n    }\r\n\r\n\r\n    private def listen(reader: PacketReader): Unit = {\r\n        try {\r\n            val bytes = reader.readNextPacketBytes()\r\n            if (bytes == null)\r\n                return\r\n\r\n            val (packet, coordinates) = packetManager.toPacket(bytes)\r\n            notifier.onPacketReceived(packet, coordinates)\r\n            handlePacket(packet, coordinates)\r\n        }\r\n        catch {\r\n            case e: AsynchronousCloseException =>\r\n                Console.err.println(\"Asynchronous close.\")\r\n                serverErrConsole.reportExceptionSimplified(e)\r\n                close(Reason.INTERNAL_ERROR)\r\n\r\n            case NonFatal(e) =>\r\n                e.printStackTrace()\r\n\r\n                Console.err.println(s\"Suddenly disconnected from the server\")\r\n                serverErrConsole.reportExceptionSimplified(e)\r\n                close(Reason.INTERNAL_ERROR)\r\n        }\r\n    }\r\n\r\n    private def handlePacket(packet: Packet, coordinates: PacketCoordinates): Unit = packet match {\r\n        case init: TaskInitPacket => tasksHandler.handlePacket(init, coordinates)\r\n        case system: SystemPacket => handleSystemPacket(system, coordinates)\r\n        case _: Packet => traffic.injectPacket(packet, coordinates)\r\n    }\r\n\r\n\r\n    private def handleSystemPacket(system: SystemPacket, coords: PacketCoordinates): Unit = {\r\n        val order = system.order\r\n        val reason = system.reason.reversed()\r\n        val origin = coords.senderID\r\n\r\n        println(s\"Received system order $order from $origin\")\r\n        notifier.onSystemOrderReceived(order, reason)\r\n\r\n        import SystemOrder._\r\n        order match {\r\n            case CLIENT_CLOSE => close(origin, reason)\r\n            case GET_IDENTIFIER => systemChannel.sendPacket(DataPacket(identifier))\r\n            case ABORT_TASK => tasksHandler.skipCurrent(reason)\r\n            case PRINT_VERSION => getConsoleOut(origin).orNull.println(s\"$relayVersion ($apiVersion)\")\r\n\r\n            case _@(SERVER_CLOSE | CHECK_ID) => sendErrorPacket(order, \"Received forbidden order.\")\r\n            case _ => sendErrorPacket(order, \"Unknown order.\")\r\n        }\r\n\r\n        def sendErrorPacket(order: SystemOrder, cause: String): Unit = {\r\n            val error = ErrorPacket(\"SystemError\",\r\n                s\"System packet order '$order' couldn't be handled by this RelayPoint.\",\r\n                cause)\r\n            systemChannel.sendPacket(error)\r\n            error.printError()\r\n        }\r\n    }\r\n\r\n    private def getExtensionFolderPath: Path = {\r\n        val path = System.getenv().get(\"COMPUTERNAME\") match {\r\n            case \"PC_MATERIEL_NET\" => \"C:\\\\Users\\\\maxim\\\\Desktop\\\\Dev\\\\VPS\\\\ClientSide\\\\RelayExtensions\"\r\n            case \"LORDI-N4SO7IERS\" => \"D:\\\\Users\\\\Maxime\\\\Desktop\\\\Dev\\\\Perso\\\\FileTransferer\\\\ClientSide\\\\RelayExtensions\"\r\n            case _ => \"RelayExtensions/\"\r\n        }\r\n        Paths.get(path)\r\n    }\r\n\r\n    private def ensureOpen(): Unit = {\r\n        if (!open)\r\n            throw new RelayClosedException(\"Relay Point have to be started !\")\r\n    }\r\n\r\n\r\n    private def ensureTargetValid(targetID: String): Unit = {\r\n        if (targetID == identifier)\r\n            throw new RelayException(\"Can't start any task with oneself !\")\r\n\r\n        systemChannel.sendOrder(SystemOrder.CHECK_ID, Reason.INTERNAL, targetID.getBytes)\r\n        val response = (systemChannel.nextPacketAsP(): DataPacket).header\r\n        if (response == \"ERROR\")\r\n            throw new RelayException(s\"Target '$targetID' does not exists !\")\r\n    }\r\n\r\n    //initial tasks\r\n    Runtime.getRuntime.addShutdownHook(new Thread(() => close(Reason.INTERNAL)))\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayPoint/src/fr/overridescala/linkkit/client/RelayPoint.scala	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ RelayPoint/src/fr/overridescala/linkkit/client/RelayPoint.scala	(date 1607515023403)
@@ -151,6 +151,7 @@
             systemChannel.sendPacket(SystemPacket(SystemOrder.CLIENT_CLOSE, reason))
         }
 
+        extensionLoader.close()
         systemChannel.close(reason)
         socket.close(reason)
         tasksHandler.close(reason)
Index: API/src/fr/overridescala/linkkit/api/extension/RelayExtension.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.linkkit.api.`extension`\r\n\r\nimport fr.overridescala.linkkit.api.Relay\r\n\r\nabstract class RelayExtension(protected val relay: Relay) {\r\n\r\n    implicit protected val self: RelayExtension = this\r\n\r\n    def main(): Unit\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/linkkit/api/extension/RelayExtension.scala	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ API/src/fr/overridescala/linkkit/api/extension/RelayExtension.scala	(date 1607514557621)
@@ -6,6 +6,7 @@
 
     implicit protected val self: RelayExtension = this
 
-    def main(): Unit
+    def onEnable(): Unit
 
+    def onDisable(): Unit = ()
 }
\ No newline at end of file
Index: API/src/fr/overridescala/linkkit/api/extension/RelayExtensionLoader.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package fr.overridescala.linkkit.api.`extension`\r\n\r\nimport java.net.URLClassLoader\r\nimport java.nio.file.{Files, Path}\r\nimport java.util.Properties\r\nimport java.util.stream.Collectors\r\nimport java.util.zip.ZipFile\r\n\r\nimport fr.overridescala.linkkit.api.Relay\r\nimport fr.overridescala.linkkit.api.`extension`.RelayExtensionLoader.{MainClassField, PropertyName}\r\nimport fr.overridescala.linkkit.api.exceptions.{RelayException, TaskExtensionLoadException}\r\n\r\nimport scala.collection.mutable.ListBuffer\r\n\r\n\r\nclass RelayExtensionLoader(relay: Relay, val extensionsFolder: Path) {\r\n\r\n    type A = Class[_ <: RelayExtension]\r\n\r\n    private val notifier = relay.eventObserver.notifier\r\n    private var classLoader: URLClassLoader = _\r\n\r\n    def loadExtensions(): Unit = {\r\n        Files.createDirectories(extensionsFolder)\r\n        val content = Files.list(extensionsFolder)\r\n        val paths = content\r\n                .filter(_.toString.endsWith(\".jar\"))\r\n                .collect(Collectors.toList[Path])\r\n                .toArray(new Array[Path](0))\r\n        val urls = paths\r\n                .map(_.toUri.toURL)\r\n        classLoader = new URLClassLoader(urls, if (classLoader == null) getClass.getClassLoader else classLoader)\r\n\r\n        val extensions = ListBuffer.empty[ExtensionInfo]\r\n\r\n        for (path <- paths) {\r\n            try {\r\n                extensions += loadJar(path)\r\n            } catch {\r\n                case e: RelayException => e.printStackTrace()\r\n            }\r\n        }\r\n        ExtensionLoaderNode.loadGraph(relay, extensions.toSeq)\r\n    }\r\n\r\n    def loadExtension[T <: RelayExtension](clazz: Class[T]): T = {\r\n        val name = retrieveInfo(clazz).name\r\n        try {\r\n            val constructor = clazz.getConstructor(classOf[Relay])\r\n            constructor.setAccessible(true)\r\n            val extension = constructor.newInstance(relay)\r\n            notifier.onExtensionLoaded(extension)\r\n            println(s\"Relay extension $name loaded successfully !\")\r\n            extension.main()\r\n            extension\r\n        } catch {\r\n            case _: NoSuchMethodException =>\r\n                throw new RelayException(s\"Could not load '$name : Constructor(Relay) is missing !\")\r\n        }\r\n    }\r\n\r\n    private def loadJar(path: Path): ExtensionInfo = {\r\n        val jarFile = new ZipFile(path.toFile)\r\n        val propertyFile = jarFile.getEntry(PropertyName)\r\n        //Checking property presence\r\n        if (propertyFile == null)\r\n            throw TaskExtensionLoadException(s\"jar file $path must have a file called '$PropertyName' in his root\")\r\n\r\n        //Checking property content\r\n        val property = new Properties()\r\n        property.load(jarFile.getInputStream(propertyFile))\r\n        val className = property.getProperty(MainClassField)\r\n        if (className == null)\r\n            throw TaskExtensionLoadException(s\"jar file $path properties' must contains a field named '$MainClassField'\")\r\n\r\n        //Loading extension's main\r\n        val clazz = classLoader.loadClass(className)\r\n        loadClass(clazz)\r\n    }\r\n\r\n    private def loadClass(clazz: Class[_]): ExtensionInfo = {\r\n        if (!classOf[RelayExtension].isAssignableFrom(clazz)) {\r\n            throw new RelayException(s\"class '$clazz' must extends '${classOf[RelayExtension]}' to be loaded as a Relay extension.\")\r\n        }\r\n        retrieveInfo(clazz.asInstanceOf[A])\r\n    }\r\n\r\n    private def retrieveInfo(extClass: A): ExtensionInfo = {\r\n        if (extClass.isAnnotationPresent(classOf[relayExtensionInfo])) {\r\n            val annotation = extClass.getAnnotation(classOf[relayExtensionInfo])\r\n            var name = annotation.name()\r\n            if (name.isEmpty) name = extClass.getSimpleName\r\n            return ExtensionInfo(annotation.dependencies, name, extClass)\r\n        }\r\n        ExtensionInfo(Array(), extClass.getSimpleName, extClass)\r\n    }\r\n\r\n}\r\n\r\nobject RelayExtensionLoader {\r\n    private val PropertyName = \"extension.properties\"\r\n    private val MainClassField = \"main\"\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- API/src/fr/overridescala/linkkit/api/extension/RelayExtensionLoader.scala	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ API/src/fr/overridescala/linkkit/api/extension/RelayExtensionLoader.scala	(date 1607515023423)
@@ -1,5 +1,6 @@
 package fr.overridescala.linkkit.api.`extension`
 
+import java.io.Closeable
 import java.net.URLClassLoader
 import java.nio.file.{Files, Path}
 import java.util.Properties
@@ -13,12 +14,19 @@
 import scala.collection.mutable.ListBuffer
 
 
-class RelayExtensionLoader(relay: Relay, val extensionsFolder: Path) {
+class RelayExtensionLoader(relay: Relay, val extensionsFolder: Path) extends Closeable  {
 
     type A = Class[_ <: RelayExtension]
 
     private val notifier = relay.eventObserver.notifier
     private var classLoader: URLClassLoader = _
+    private val loadedExtensions = ListBuffer.empty[RelayExtension]
+
+    override def close(): Unit = {
+          //TODO print "Disabling '[extesionName]'...
+          loadedExtensions.foreach(extension => extension.onDisable())
+          loadedExtensions.clear()
+    }
 
     def loadExtensions(): Unit = {
         Files.createDirectories(extensionsFolder)
@@ -51,7 +59,8 @@
             val extension = constructor.newInstance(relay)
             notifier.onExtensionLoaded(extension)
             println(s"Relay extension $name loaded successfully !")
-            extension.main()
+            loadedExtensions += extension
+            extension.onEnable()
             extension
         } catch {
             case _: NoSuchMethodException =>
@@ -59,6 +68,8 @@
         }
     }
 
+
+
     private def loadJar(path: Path): ExtensionInfo = {
         val jarFile = new ZipFile(path.toFile)
         val propertyFile = jarFile.getEntry(PropertyName)
Index: MoodCollector/MoodCollectorServer/MoodCollectorServer.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"module\" module-name=\"API\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- MoodCollector/MoodCollectorServer/MoodCollectorServer.iml	(revision a6dbe7d3cc6c66fc9af289abb472afd77a0aa1b8)
+++ MoodCollector/MoodCollectorServer/MoodCollectorServer.iml	(date 1607516338580)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
+<module version="4">
   <component name="NewModuleRootManager" inherit-compiler-output="true">
     <exclude-output />
     <content url="file://$MODULE_DIR$">
@@ -9,5 +9,6 @@
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
     <orderEntry type="module" module-name="API" />
+    <orderEntry type="library" name="org.xerial:sqlite-jdbc:3.32.3.2" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: MoodCollector/MoodCollectorClient/MoodCollectorClient.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"module\" module-name=\"API\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- MoodCollector/MoodCollectorClient/MoodCollectorClient.iml	(revision a6dbe7d3cc6c66fc9af289abb472afd77a0aa1b8)
+++ MoodCollector/MoodCollectorClient/MoodCollectorClient.iml	(date 1607516338560)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
+<module version="4">
   <component name="NewModuleRootManager" inherit-compiler-output="true">
     <exclude-output />
     <content url="file://$MODULE_DIR$">
@@ -9,5 +9,6 @@
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
     <orderEntry type="module" module-name="API" />
+    <orderEntry type="library" name="org.xerial:sqlite-jdbc:3.32.3.2" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: .gitmodules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[submodule \"RelayEnviExtensions\"]\r\n\tpath = RelayEnviExtensions\r\n\turl = https://github.com/Override-6/RelayEnviExtensions\r\n[submodule \"LinkKitExtensions\"]\r\n\tpath = LinkKitExtensions\r\n\turl = https://github.com/Override-6/LinkKitExtensions\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .gitmodules	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ .gitmodules	(date 1607509348257)
@@ -4,3 +4,6 @@
 [submodule "LinkKitExtensions"]
 	path = LinkKitExtensions
 	url = https://github.com/Override-6/LinkKitExtensions
+[submodule "MoodCollector"]
+	path = MoodCollector
+	url = https://github.com/Override-6/MoodCollector
Index: RelayPoint/RelayPoint.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"library\" name=\"scala-sdk-2.13.3\" level=\"application\" />\r\n    <orderEntry type=\"module\" module-name=\"API\" />\r\n    <orderEntry type=\"module\" module-name=\"CloudStorage\" />\r\n    <orderEntry type=\"module\" module-name=\"DebugExtension\" />\r\n    <orderEntry type=\"module\" module-name=\"RelayController\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- RelayPoint/RelayPoint.iml	(revision 655ed6943e3788d184d2b49569d3857e837ccb4f)
+++ RelayPoint/RelayPoint.iml	(date 1607516338596)
@@ -10,7 +10,6 @@
     <orderEntry type="library" name="scala-sdk-2.13.3" level="application" />
     <orderEntry type="module" module-name="API" />
     <orderEntry type="module" module-name="CloudStorage" />
-    <orderEntry type="module" module-name="DebugExtension" />
     <orderEntry type="module" module-name="RelayController" />
   </component>
 </module>
\ No newline at end of file
