
//Normal imports
import fr.overrride.game.shooter.api.other.GraphicComponent
import fr.overrride.game.shooter.api.session.character.Collidable
import fr.overrride.game.shooter.session.character.ShooterCharacter

//Scala imports
scala import fr.example.ExampleObject

//Disabling a class means that all of its fields and methods are not synchronized
disable class GraphicComponent
disable class Collidable
// We describe the class's Behavior. the class names after ':' are used to inherit the method behaviors of the classes
// (the described class, (here ShooterCharacter), must extend or implement those classes
                                // Specified classes that we want to inherit behaviors
                                //(is useful only if behavior descriptors for those classes exists in the used behavior store)
describe class ShooterCharacter : GraphicComponent, Collidable {
    
    forall method -> disable //We disable all methods by default
    
    //describing the dash and kill methods. 
    [procrastinator = @lwjgl] //We use the lwjgl thread pool in which we want the method to be processed if the execution was triggered from a RMI request.
                   // The RMI rule which says that the remote call must be broadcasted to every connected clients (only if the method is called on an object owned by the current engine)
    enable dash, kill as broadcast(if owner)
    
    //The behavior of dash is pasted to these methods
    enable setWeapon, damage, heal, setHealth as dash
    
    //Same behavior as dash excepted that we don't specify an executor
    [procrastinator = none]
    enable shoot as dash
    
    //Here is another method example
                            //We describe the rule using scala code
    enable exampleMethod as ${agreement => { agreement
                                                   .ifCurrentIsNotOwner(_.discardAll)
                                                   .setDesiredCurrentEngineReturn()}} {
         // We describe the arguments
         params {
            enable arg1 { //Enabling the argument, (it will be synchronized too)
                modifier for local -> ${arg => new ModifiedArgument(arg.value + 1)}  //modifier applied if the method invocation comes from a RMI request
                modifier for remote -> ${(arg, engineID) => if (engineID != "DumbEngine") localModifier(arg) else null} //Modifier applied in order to modify the arguments of the RMI request of any engineID
            }
            //We don't want this argument to be synchronized, however, we still want it to be modified as for arg1.
            disable arg2 as arg1 {
                modifier for remote -> ${arg, engineID => if (engineID != "DumbEngine") localModifier(arg) else ExampleObject.modified(arg)}
            }
         }         
         returnvalue -> disable //we don't want the returnvalue of this method to be synchronized
    }

    //Let's say that the exampleMethod returns an integer.
    enable exampleMethod2 as @complexBehavior("Hello") { //We can take a behavior from the tree context, giving the factory argument if defined
             returnvalue -> disable { //we don't want the returnvalue of this method to be synchronized (we can't synchronize primitives)
                modifier from remote -> ${x => x * 2} //however we modify it if the invocation comes from a distant engine
             }
    }

    //the method won't even be called by any RMI.
    hide getPassword
}

//Behavior for fields of type 'ShooterCharacter' (excepted excluded classes, only for included classes)
describe class ShooterCharacter when field [- ExcludedClass -] [+ IncludedClass +] {
    modifier for local -> ${ (parent, theField) =>
        println(s"I'm the field of '$parent' and i'm being modified !")
        theField.setHealth(455)
        theField
    }
    modifier for remote -> ${ (parent, theField, engineID) =>
        println(s"I'm the field of the object '$parent', sent by engine '$engineID' and i'm being modified !")
        theField.kill()
        theField
    }
}
//Behavior for methods parameters of type 'ShooterCharacter' (excepted for excluded methods or methods that comes from an excluded class)
describe class ShooterCharacter when parameter [- ExcludedClass, AnotherExcludedClass.excludedMethod -] {
    modifier for local -> ${ (invocation, param) =>
        val guardian = invocation.getGuardianOf[SimpleGuardian](param)
        if (guardian.haveChangedSinceNInvocations(3)) //It's the same parameter since 3 invocations
            param.modify()
        param
    }
}
//Behavior for methods return values of type 'ShooterCharacter'.
describe class ShooterCharacter when returnvalue [+ IncludedClass, OtherIncludedClass.{includedMethod1, includedMethod2} +] {
    modifier for local -> ${ (invocation, value) =>
        value match {
            case syncObject: SynchronizedObject[_] => syncObject.detachedClone();
            case other                             => other
        }
        //Modify
    }
    modifier for remote -> ${ (invocation, value, engineID) =>
        //Modify
    }
}
