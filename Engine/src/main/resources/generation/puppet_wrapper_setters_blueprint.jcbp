/*
 *  Copyright (c) 2021. Linkit and or its affiliates. All rights reserved.
 *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 *  This code is free software; you can only use it for personal uses, studies or documentation.
 *  You can download this source code, and modify it ONLY FOR PERSONAL USE and you
 *  ARE NOT ALLOWED to distribute your MODIFIED VERSION.
 *
 *  Please contact maximebatista18@gmail.com if you need additional information or have any
 *  questions.
 */

package gen.$WrappedClassPackage$;

import $WrappedClassName$;

public class Setters$WrappedClassSimpleName$ $TParamsIn$ extends $WrappedClassSimpleName$ $TParamsOut$ implements PuppetWrapper<$WrappedClassSimpleName$> {

    public static final long serialVersionUID = $CompileTime$L;
    protected transient Puppeteer<$WrappedClassSimpleName$> puppeteer;
    protected transient PuppetDescription<$WrappedClassSimpleName$> description;
    protected transient InvocationChoreographer choreographer;
    protected PuppeteerDescription puppeteerDescription;

    public Puppet$WrappedClassSimpleName$(Puppeteer<$WrappedClassSimpleName$> bundle, $WrappedClassSimpleName$ clone) {
        super(clone);
        initPuppeteer(bundle);
    }

    //Fun fact: Override annotations are conventional.
    //They does not affect abstraction or classes behaviors.
    //Override annotations are removed at compilation.

    @Override
    public void initPuppeteer(Puppeteer<$WrappedClassSimpleName$> puppeteer) throws PuppetAlreadyInitialisedException {
        if (this.puppeteer != null)
        throw new PuppetAlreadyInitialisedException("This puppet is already initialized !");
        this.puppeteer = puppeteer;
        this.puppeteerDescription = this.puppeteer.puppeteerDescription();
        this.description = puppeteer.puppetDescription();
        this.puppeteer.init(this);
        this.choreographer = new InvocationChoreographer();
    }

    @Override
    public boolean isInitialized() {
        return puppeteer != null;
    }

    @Override
    public $WrappedClassSimpleName$ detachedSnapshot() {
        return new $WrappedClassSimpleName$(this);
    }

    @Override
    public $WrappedClassSimpleName$ getValue() {
        return this;
    }

    @Override
    public InvocationChoreographer getChoreographer() {
        return choreographer;
    }

    @Override
    public Puppeteer<$WrappedClassSimpleName$> getPuppeteer() {
        return puppeteer;
    }

    @Override
    public PuppeteerDescription getPuppeteerDescription() {
        return puppeteerDescription;
    }

    private <T> T performRmi(int id, Object[] args, Supplier<T> superCall, T defaultResult) {
        if (choreographer.isMethodExecutionForcedToLocal() || !description.isRMIEnabled(id)) {
            return superCall.get();
        }
        //# From here we are sure that we want to perform a remote
        //# method invocation. (A Local invocation (super.xxx()) can be added).
        if (description.isInvokeOnly(id)) {
            puppeteer.sendInvoke(id, args);
            T localResult = defaultResult;
            if (description.isLocalInvocationForced(id)) {
                localResult = superCall.get();
            }
            return localResult;
        }
        T result;
        if (description.isLocalInvocationForced(id)) {
            result = superCall.get();
            puppeteer.sendInvoke(id, args);
        } else {
            result = puppeteer.sendInvokeAndWaitResult(id, args);
        }
        return result;
    }

!!INHERITED_METHODS!! {
    @Override
    public $GenericTypes$ $ReturnType$ $MethodName$$ParamsIn$ $MethodExceptions$ {
        $|If ReturnType == "void" |$ {
            performRmi($MethodID$, new Object[]{$ParamsOut$}, () -> super.$MethodName$($ParamsOut$), $DefaultReturnType$)
        } $|Else|$ {
            return performRmi($MethodID$, new Object[]{$ParamsOut$}, () -> super.$MethodName$($ParamsOut$), $DefaultReturnType$)
        }
    }
}
}