/*
 *  Copyright (c) 2021. Linkit and or its affiliates. All rights reserved.
 *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 *  This code is free software you can only use it for personal uses, studies or documentation.
 *  You can download this source code, and modify it ONLY FOR PERSONAL USE and you
 *  ARE NOT ALLOWED to distribute your MODIFIED VERSION.
 *
 *  Please contact maximebatista18@gmail.com if you need additional information or have any
 *  questions.
 */

package gen.$WrappedClassPackage$

import $WrappedClassName$
import fr.linkit.api.connection.cache.repo.InvocationChoreographer
import fr.linkit.api.connection.cache.repo.description.{PuppetDescription, PuppeteerDescription}
import fr.linkit.api.connection.cache.repo.PuppetWrapper
import fr.linkit.api.connection.cache.repo.Puppeteer
import fr.linkit.engine.connection.cache.repo.PuppetAlreadyInitialisedException
import fr.linkit.engine.connection.cache.repo.generation.WrapperInstantiator
import fr.linkit.engine.local.utils.JavaUtils.{getNull => nl}
import fr.linkit.engine.local.utils.ScalaUtils

@SerialVersionUID($CompileTime$L)
class Puppet$WrappedClassSimpleName$$TParamsIn$
    extends Setters$WrappedClassSimpleName$$TParamsOut$ {

    //Fun fact: Override annotations are conventional.
    //They does not affect abstraction or classes behaviors.
    //Override annotations are removed at compilation.

    @inline private def performRMI[R](@inline id: Int, @inline defaultReturnValue: R, @inline invokeOnlyResult: R)
                                     (@inline args: Array[Array[Any]])(@inline superCall: => R): R = {
        if (choreographer.isMethodExecutionForcedToLocal || !description.isRMIEnabled(id)) {
            return superCall
        }
        // From here we are sure that we want to perform a remote
        // method invocation. (A Local invocation (super.xxx()) can be added).
        if (description.isInvokeOnly(id)) {
            puppeteer.sendInvoke(id, args)
            var localResult: Any = defaultReturnValue
            if (description.isLocalInvocationForced(id)) {
                localResult = superCall
            }
            //# Note1: value of 'InvokeOnlyResult' can be "localResult", which will return the variable.
            //# Note2: Be aware that you can get a null value returned
            //#        if the 'InvokeOnlyResult' value of the annotated
            //#        method is set to "localResult" and the invocation
            //#        kind does not force local invocation.
            return invokeOnlyResult
        }
        var result: R = defaultReturnValue
        if (description.isLocalInvocationForced(id)) {
            result = superCall
            puppeteer.sendInvoke(id, args)
        } else {
            result = puppeteer.sendInvokeAndWaitResult[R](id, args)
        }
        result
    }

!!INHERITED_METHODS!! {
    override def $MethodName$$GenericTypesIn$$ParamsIn$: $ReturnType$ = {
        performRMI[$ReturnType$]($MethodID$, $DefaultReturnValue$, $InvokeOnlyResult$)(Array[Array[Any]]($ParamsOutArray$))(super.$MethodName$$GenericTypesOut$$ParamsOut$)
    }
}
}
