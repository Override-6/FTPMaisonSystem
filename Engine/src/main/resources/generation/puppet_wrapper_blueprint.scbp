/*
 *  Copyright (c) 2021. Linkit and or its affiliates. All rights reserved.
 *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 *  This code is free software you can only use it for personal uses, studies or documentation.
 *  You can download this source code, and modify it ONLY FOR PERSONAL USE and you
 *  ARE NOT ALLOWED to distribute your MODIFIED VERSION.
 *
 *  Please contact maximebatista18@gmail.com if you need additional information or have any
 *  questions.
 */

package gen.$WrappedClassPackage$

import $WrappedClassName$
import fr.linkit.api.connection.cache.repo.InvocationChoreographer
import fr.linkit.api.connection.cache.repo.description.PuppetDescription
import fr.linkit.api.connection.cache.repo.PuppetWrapper
import fr.linkit.api.connection.cache.repo.Puppeteer
import fr.linkit.api.connection.cache.repo.generation.PuppeteerDescription
import fr.linkit.engine.connection.cache.repo.PuppetAlreadyInitialisedException

@SerialVersionUID($CompileTime$L)
class Puppet$WrappedClassSimpleName$$TParamsIn$(private var puppeteer: Puppeteer[$WrappedClassSimpleName$$TParamsOut$],
                                                 private val clone: $WrappedClassSimpleName$$TParamsOut$)
    extends $WrappedClassSimpleName$$TParamsOut$(clone) with PuppetWrapper[$WrappedClassSimpleName$$TParamsOut$] {

    @transient private var description: PuppetDescription[$WrappedClassSimpleName$$TParamsOut$] = _
    @transient private var choreographer: InvocationChoreographer = _
    @transient private var puppeteerDescription: PuppeteerDescription = _
    initPuppeteer(puppeteer)

    //Fun fact: Override annotations are conventional.
    //They does not affect abstraction or classes behaviors.
    //Override annotations are removed at compilation.

    override def initPuppeteer(puppeteer: Puppeteer[$WrappedClassSimpleName$$TParamsIn$]): Unit = {
        if (this.puppeteer != null)
            throw new PuppetAlreadyInitialisedException("This puppet is already initialized !")
        this.puppeteer = puppeteer
        this.puppeteerDescription = this.puppeteer.puppeteerDescription
        this.description = puppeteer.puppetDescription
        this.puppeteer.init(this)
        this.choreographer = new InvocationChoreographer()
    }

    override def isInitialized: Boolean = puppeteer != null

    override def detachedSnapshot: $WrappedClassSimpleName$$TParamsIn$ = {
        new $WrappedClassSimpleName$(this)
    }

    override def getValue: $WrappedClassSimpleName$$TParamsIn$ = this

    override def getChoreographer: InvocationChoreographer = choreographer

    override def getPuppeteer: Puppeteer[$WrappedClassSimpleName$$TParamsIn$] = puppeteer

    override def getPuppeteerDescription: PuppeteerDescription = puppeteerDescription

!!INHERITED_METHODS!! {
    override def $MethodName$$GenericTypesIn$$ParamsIn$: $ReturnType$ = {
        if (choreographer.isMethodExecutionForcedToLocal || !description.isRMIEnabled($MethodID$)) {
            return super.$MethodName$$GenericTypesOut$$ParamsOut$
        }
        val args = Array[Any]($ParamsOut$)
        //# From here we are sure that we want to perform a remote
        //# method invocation. (A Local invocation (super.xxx()) can be added).
        if (description.isInvokeOnly($MethodID$)) {
            puppeteer.sendInvoke($MethodID$, args)
            var localResult: $ReturnType$ = $DefaultReturnType$
            if (description.isLocalInvocationForced($MethodID$)) {
                localResult = super.$MethodName$$GenericTypesOut$$ParamsOut$
            }
            //# Note1: value of 'InvokeOnlyResult' can be "localResult".
            //# Note2: Be aware that you can get a null value returned
            //#        if the 'InvokeOnlyResult' value of the annotated
            //#        method is set to "localResult" and the invocation
            //#        kind does not force local invocation.
            return $InvokeOnlyResult$
        }
        var result: $ReturnType$ = $DefaultReturnType$
        if (description.isLocalInvocationForced($MethodID$)) {
            result = super.$MethodName$$GenericTypesOut$$ParamsOut$
            puppeteer.sendInvoke($MethodID$, args)
        } else {
            result = puppeteer.sendInvokeAndWaitResult($MethodID$, args)
        }
        result
    }

}
}
