/*
 *  Copyright (c) 2021. Linkit and or its affiliates. All rights reserved.
 *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 *  This code is free software; you can only use it for personal uses, studies or documentation.
 *  You can download this source code, and modify it ONLY FOR PERSONAL USE and you
 *  ARE NOT ALLOWED to distribute your MODIFIED VERSION.
 *
 *  Please contact maximebatista18@gmail.com if you need additional information or have any
 *  questions.
 */

package gen.$WrappedClassPackage$;

import $WrappedClassName$;
import fr.linkit.api.connection.cache.repo.InvocationChoreographer;
import fr.linkit.api.connection.cache.repo.description.PuppetDescription;
import fr.linkit.api.connection.cache.repo.PuppetWrapper;
import fr.linkit.api.connection.cache.repo.Puppeteer;
import fr.linkit.api.connection.cache.repo.generation.PuppeteerDescription;
import fr.linkit.engine.connection.cache.repo.PuppetAlreadyInitialisedException;

public class Puppet$WrappedClassSimpleName$ extends $WrappedClassSimpleName$ implements PuppetWrapper<$WrappedClassSimpleName$> {

    public static final long serialVersionUID = $CompileTime$L;
    private transient Puppeteer<$WrappedClassSimpleName$> puppeteer;
    private transient PuppetDescription<$WrappedClassSimpleName$> description;
    private transient InvocationChoreographer choreographer;
    private PuppeteerDescription puppeteerDescription;

    public Puppet$WrappedClassSimpleName$(Puppeteer<$WrappedClassSimpleName$> bundle, $WrappedClassSimpleName$ clone) {
        super(clone);
        initPuppeteer(bundle);
    }

    //Fun fact: Override annotations are conventional.
    //They does not affect abstraction or classes behaviors.
    //Override annotations are removed at compilation.

    @Override
    public void initPuppeteer(Puppeteer<$WrappedClassSimpleName$> puppeteer) throws PuppetAlreadyInitialisedException {
        if (this.puppeteer != null)
            throw new PuppetAlreadyInitialisedException("This puppet is already initialized !");
        this.puppeteer = puppeteer;
        this.puppeteerDescription = this.puppeteer.puppeteerDescription();
        this.description = puppeteer.puppetDescription();
        this.puppeteer.init(this);
        this.choreographer = new InvocationChoreographer();
    }

    @Override
    public boolean isInitialized() {
        return puppeteer != null;
    }

    @Override
    public $WrappedClassSimpleName$ detachedClone() {
        return new $WrappedClassSimpleName$(this);
    }

    @Override
    public $WrappedClassSimpleName$ getValue() {
        return this;
    }

    @Override
    public InvocationChoreographer getChoreographer() {
        return choreographer;
    }

    @Override
    public Puppeteer<$WrappedClassSimpleName$> getPuppeteer() {
        return puppeteer;
    }

    @Override
    public PuppeteerDescription getPuppeteerDescription() {
        return puppeteerDescription;
    }

$$INHERITED_METHODS$$ {
    @Override
    public $ReturnType$ $MethodName$($ParamsIn$) $MethodExceptions$ {
        if (choreographer.isMethodExecutionForcedToLocal() || !description.isRMIEnabled($MethodID$)) {
            $|If ReturnType == "void"|$ {
                super.$MethodName$($ParamsOut$);
                return;
            } $|Else|$ {
                return super.$MethodName$($ParamsOut$);
            }
        }
        final Object[] args = new Object[]{$ParamsOut$};
        //# From here we are sure that we want to perform a remote
        //# method invocation. (A Local invocation (super.xxx()) can be added).
        if (description.isInvokeOnly($MethodID$)) {
            puppeteer.sendInvoke($MethodID$, args);
            $|If ReturnType != "void"|$ {
                $ReturnType$ localResult;
                if (description.isLocalInvocationForced($MethodID$)) {
                    localResult = super.$MethodName$($ParamsOut$);
                }
                //# Note1: value of 'InvokeOnlyResult' can be "localResult".
                //# Note2: Be aware that you can get a null value returned
                //#        if the 'InvokeOnlyResult' value of the annotated
                //#        method is set to "localResult" and the invocation
                //#        kind does not force local invocation.
                return $InvokeOnlyResult$;
            } $|Else|$ {
                if (description.isLocalInvocationForced($MethodID$)) {
                    super.$MethodName$($ParamsOut$);
                }
                return;
            }
        }
        $|If ReturnType != "void"|$ {
            $ReturnType$ result;
            if (description.isLocalInvocationForced($MethodID$)) {
                result = super.$MethodName$($ParamsOut$);
                puppeteer.sendInvoke($MethodID$, args);
            } else {
                result = puppeteer.sendInvokeAndWaitResult($MethodID$, args);
            }
            return result;
        } $|Else|$ {
            super.$MethodName$($ParamsOut$);
            puppeteer.sendInvoke($MethodID$, args);
            return;
        }
    }

}
}
