/*
 *  Copyright (c) 2021. Linkit and or its affiliates. All rights reserved.
 *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 *  This code is free software; you can only use it for personal uses, studies or documentation.
 *  You can download this source code, and modify it ONLY FOR PERSONAL USE and you
 *  ARE NOT ALLOWED to distribute your MODIFIED VERSION.
 *
 *  Please contact maximebatista18@gmail.com if you need additional information or have any
 *  questions.
 */

package gen.$WrappedClassPackage$;

import $WrappedClassPackage$.$WrappedClassSimpleName$;
import fr.linkit.api.connection.cache.repo.PuppetDescription;
import fr.linkit.api.connection.cache.repo.PuppetWrapper;
import fr.linkit.api.connection.cache.repo.Puppeteer;
import fr.linkit.api.connection.cache.repo.generation.PuppeteerDescription;
import fr.linkit.engine.connection.cache.repo.PuppetAlreadyInitialisedException;

public class Puppet$WrappedClassSimpleName$ extends $WrappedClassSimpleName$ implements PuppetWrapper<$WrappedClassSimpleName$> {

    public static final long serialVersionUID = $CompileTime$L;
    private transient Puppeteer<$WrappedClassSimpleName$> puppeteer;
    private transient PuppetDescription<$WrappedClassSimpleName$> description;
    private PuppeteerDescription puppeteerDescription;

    public Puppet$WrappedClassSimpleName$(Puppeteer<$WrappedClassSimpleName$> bundle, $WrappedClassSimpleName$ clone) {
        super(clone);
        initPuppeteer(bundle, clone);
    }

    //Fun fact: Override annotations are only conventional.
    //They are only informal and
    //does not affect abstraction or classes behaviors.
    //Override annotations are removed at compilation.

    @Override
    public void initPuppeteer(Puppeteer<$WrappedClassSimpleName$> puppeteer, $WrappedClassSimpleName$ clone) throws PuppetAlreadyInitialisedException {
        if (this.puppeteer != null)
            throw new PuppetAlreadyInitialisedException("This puppet is already initialized !");
        this.puppeteer = puppeteer;
        this.puppeteerDescription = this.puppeteer.puppeteerDescription();
        this.description = puppeteer.puppetDescription();
        this.puppeteer.init(this, clone);
    }

    @Override
    public boolean isInitialized() {
        return puppeteer != null;
    }

    @Override
    public $WrappedClassSimpleName$ detachedClone() {
        return new $WrappedClassSimpleName$(this);
    }

    @Override
    public PuppeteerDescription getPuppeteerDescription() {
        return puppeteerDescription;
    }

$$INHERITED_METHODS$$ {
    @Override
    public $ReturnType$ $MethodName$($ParamsIn$) $MethodExceptions$ {
        if (!description.isRMIEnabled($MethodID$)) {
            $|If ReturnType == "void"|$ {
                super.$MethodName$($ParamsOut$);
                return;
            } $|Else|$ {
                return super.$MethodName$($ParamsOut$);
            }
        }
        if (description.isInvokeOnly($MethodID$)) {
            puppeteer.sendInvoke($MethodID$, new Object[]{$ParamsOut$});
            $|If ReturnType != "void"|$ {
                return $InvokeOnlyResult$;
            } $|Else|$ {
                return;
            }
        }
        $|If ReturnType != "void"|$ {
            return puppeteer.sendInvokeAndWaitResult($MethodID$, new Object[]{$ParamsOut$});
        } $|Else|$ {
            return;
        }
    }
}
}